/* ffc - faster file compare
 * dump/quick replacement for Windows' crappy fc.exe,
 * mainly for .wav files generated by vgmstream.
 *
 * compares file1 and file2, returns errno if files are different
 * (returns on first diff, while fc.exe compares the whole thing).
 *
 * Also has a mode for 'fuzzy' sameness (samples +-N) for pcm files.
 *
 * Can compare simple WAVs headers (only fmt/data chunks, to be improved)
 */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>

#define MAX_FUZZY_DIFFS 2
#define BUFFER_SIZE 0x8000
#define FLOAT_SCALE 32768.0f

static void usage(const char* name) {
    fprintf(stderr,"ffc \n\n"
            "Usage: %s (infile1) (infile2) [mode]\n"
            "  mode: e=exact, f=float (fuzzy), p=pcm16 (fuzzy)\n"
            ,name);
}

typedef enum { MODE_EXACT, MODE_F32_FUZZY, MODE_S16_FUZZY, } mode_t;


static inline uint32_t get_u32le(const uint8_t* p) {
    return ((uint32_t)p[0]) | ((uint32_t)p[1]<<8) | ((uint32_t)p[2]<<16) | ((uint32_t)p[3]<<24);
}

static int get_start(FILE* file1) {
    uint8_t buf[0x100];

    fread(buf, sizeof(uint8_t), sizeof(buf), file1);
    fseek(file1, 0, SEEK_SET);

    uint32_t riff_id = get_u32le(buf + 0x00);
    if (riff_id != 0x46464952) //RIFF
        return 0;

    int fmt_size = get_u32le(buf + 0x10);

    int next_chunk = fmt_size + 0x14;
    if (next_chunk > sizeof(buf) - 0x08)
        return 0;

    uint32_t chunk_id = get_u32le(buf + next_chunk);
    if (chunk_id != 0x61746164) //data
        return 0;

    return next_chunk + 0x08;
}

static int compare_exact(FILE* file1, FILE* file2, int start, int filesize) {
    uint8_t buffer1[BUFFER_SIZE];
    uint8_t buffer2[BUFFER_SIZE];

    while (start < filesize) {
        size_t read1 = fread(buffer1, sizeof(uint8_t), BUFFER_SIZE, file1);
        size_t read2 = fread(buffer2, sizeof(uint8_t), BUFFER_SIZE, file2);

        if (read1 == 0 || read2 == 0) // || read1 != read2
            return -start;

#if 0
        /* fails faster but slower to compare? (fail is less common case) */ 
        for (int i = 0; i < read1; i++) {
            if (buffer1[i] != buffer2[i])
                return -(start + i);
        }
#else
        /* faster to compare but does't fail as fast */
        if (memcmp(buffer1, buffer2, read1) != 0)
            return -start;
#endif

        start += read1;
    }

    return 0;
}


static int compare_float_fuzzy(FILE* file1, FILE* file2, int start, int filesize) {
    uint8_t buffer1[BUFFER_SIZE];
    uint8_t buffer2[BUFFER_SIZE];
    float* buf_flt1 = (float*)&buffer1[0];
    float* buf_flt2 = (float*)&buffer2[0];

    int fuzz = 0;

    while (start < filesize) {
        size_t read1 = fread(buffer1, sizeof(uint8_t), BUFFER_SIZE, file1);
        size_t read2 = fread(buffer2, sizeof(uint8_t), BUFFER_SIZE, file2);

        if (read1 == 0 || read2 == 0) // || read1 != read2
            return -start;

        int samples = read1 / 4;
        for (int i = 0; i < samples; i++) {
            float val1 = buf_flt1[i];
            float val2 = buf_flt2[i];
            if (val1 == val2)
                continue;
            
            val1 *= FLOAT_SCALE;
            val1 *= FLOAT_SCALE;

            int diff = val1 - val2;
            if (diff < 0)
                diff = -diff;
            if (diff > MAX_FUZZY_DIFFS)
                return -(start + i * 4);

            fuzz = start; //not same or bigger than diff = fuzzy
        }

        start += read1;
    }

    if (fuzz)
        return fuzz;
    return 0;
}

static int compare_pcm16_fuzzy(FILE* file1, FILE* file2, int start, int filesize) {
    uint8_t buffer1[BUFFER_SIZE];
    uint8_t buffer2[BUFFER_SIZE];
    short* buf_pcm1 = (short*)&buffer1[0];
    short* buf_pcm2 = (short*)&buffer2[0];

    int fuzz = 0;

    while (start < filesize) {
        size_t read1 = fread(buffer1, sizeof(uint8_t), BUFFER_SIZE, file1);
        size_t read2 = fread(buffer2, sizeof(uint8_t), BUFFER_SIZE, file2);

        if (read1 == 0 || read2 == 0) // || read1 != read2
                return -start;

        int samples = read1 / 2;
        for (int i = 0; i < samples; i++) {
            short val1 = buf_pcm1[i];
            short val2 = buf_pcm2[i];
            if (val1 == val2)
                continue;

            int diff = val1 - val2;
            if (diff < 0)
                diff = -diff;
            if (diff > MAX_FUZZY_DIFFS)
                return -(start + i * 2);

            fuzz = start; //not same or bigger than diff = fuzzy
        }

        start += read1;
    }

    if (fuzz)
        return fuzz;
    return 0;
}


int main(int argc, char** argv) {
    FILE* file1 = NULL;
    FILE* file2 = NULL;
    size_t filesize1;
    size_t filesize2;
    int start = 0;
    mode_t mode = MODE_EXACT;

    if (argc < 3) {
        usage(argv[0]);
        return -1;
    }

    /* open */
    file1 = fopen(argv[1], "rb");
    if (!file1) goto fail_files;

    file2 = fopen(argv[2], "rb");
    if (!file2) goto fail_files;

    if (argc >= 4) {
        char mode_flag = argv[3][0];
        switch (mode_flag) {
            case 'p':   mode = MODE_S16_FUZZY; break;
            case 'f':   mode = MODE_F32_FUZZY; break;
            default:    mode = MODE_EXACT; break;
        }
    }

    /* sizes */
    if (fseek(file1, 0, SEEK_END) == -1)
        goto fail_files;
    filesize1 = ftell(file1);
    fseek(file1, 0, SEEK_SET);

    if (fseek(file2, 0, SEEK_END) == -1)
        return 2;
    filesize2 = ftell(file2);
    fseek(file2, 0, SEEK_SET);

    if (filesize1 != filesize2) {
        fprintf(stderr, "FFC: different size (%s=%x vs %s=%x)\n", argv[1], filesize1, argv[2], filesize2);
        goto fail_diff;
    }

    start = get_start(file1);
            
    {
        int res = 0;
        switch(mode) {
            case MODE_S16_FUZZY:
                printf("comparing pcm16 fuzzy at %x\n", start);
                res = compare_pcm16_fuzzy(file1, file2, start, filesize1);
                break;
            case MODE_F32_FUZZY:
                printf("comparing f32 fuzzy at %x\n", start);
                res = compare_float_fuzzy(file1, file2, start, filesize1);
                break;
            default:
                printf("comparing exact at %x\n", start);
                res = compare_exact(file1, file2, start, filesize1);
                break;
        }
        
        if (res == 0) {
            printf("FFC: same file\n");
        }
        if (res > 0) {
            printf("FFC: fuzzy file (%s vs %s)\n", argv[1], argv[2]);
        }
        if (res < 0) {
            fprintf(stderr, "FFC: different file (%s vs %s) near %x\n", argv[1], argv[2], -res);
            goto fail_diff;
        }
    }

    fclose(file1);
    fclose(file2);
    errno = 0;
    return 0; /* same */

fail_diff:
    fclose(file1);
    fclose(file2);
    errno = 1;
    return 1; /* files are different */

fail_files:
    fprintf(stderr, "FFC: file error (%s vs %s)\n", argv[1], argv[2]);
    fclose(file1);
    fclose(file2);
    errno = 2;
    return 2; /* cannot find at least one of the files */
}
